## Solution

| 분류 | 방법 | 설명 | 장점 | 단점 | 추천 상황 |
|------|------|------|------|------|-----------|
| Java 동기화 기법 | synchronized | 특정 코드 블록이나 메서드에 대해 JVM 단위 락을 사용 | 간단하고 직관적 | 블로킹, 성능 저하 | 단일 인스턴스, 소규모 서버 |
|  | ReentrantLock | 락 획득/해제 타이밍 제어 가능 (tryLock, timeout 등) | 세밀한 제어 | 실수로 락 미해제 가능 | 단일 인스턴스에서 정밀 제어 필요할 때 |
|  | LockSupport | 낮은 수준의 스레드 park/unpark 제어 제공 | 고급 제어 가능 | 복잡하고 위험 | 커스텀 동기화 로직 구현 시 |
| DB 기반 | 비관적 락 (SELECT FOR UPDATE) | 트랜잭션 중 다른 트랜잭션을 차단 | 확실한 보장 | 락 경합 시 성능 저하 | 금융/거래 등 실수 허용 불가 |
|  | 낙관적 락 (@Version) | 버전 비교 후 update → 충돌 시 예외 | 락 없이 성능 유지 | 충돌 시 재시도 필요 | 충돌 확률 낮은 환경 |
| 캐시/Redis 기반 | Redis INCR/DECR | Redis의 원자적 카운트 조작 | 빠르고 간단 | TTL/초기화 관리 필요 | 예약 건수 등 단일 자원 제어 |
|  | Redis SETNX | 키 없을 때만 설정 (Lock) | 단순 락 구현 가능 | 재시도 로직 필요 | 간단한 분산 락 |
|  | Redisson Lock | Lua + watchdog 기반 분산 락 제공 | 분산 환경 보장 | 외부 라이브러리 의존 | 다중 인스턴스 환경 |
|  | Redis + Lua Script | 복합 로직을 원자적으로 실행 | 락 없이 원자성 보장 | 스크립트 디버깅 어려움 | 예약 건수 제한 등 복합 조건 |
| 메시지 기반 | 메시지 큐 (Kafka 등) | 요청을 큐잉해 직렬화 | 완전한 순차 보장 | 실시간성 떨어짐 | 쓰기/수정 요청 순차 처리 시 |
| OS/파일 기반 | File Lock | OS 파일 락으로 제어 | 분산 환경에서 사용 가능 | 느리고 복잡 | 로그/배치 중복 방지 등 |
| DB 제약조건 | Unique Key | 중복 삽입을 DB에서 방지 | DB가 보장 | 충돌 시 예외 처리 필요 | 멱등성 처리 등 |
| 외부 락 시스템 | ZooKeeper, etcd | 고가용 분산 락 시스템 | 높은 신뢰성 | 복잡도와 운영 비용 ↑ | 대규모 분산 환경 |
